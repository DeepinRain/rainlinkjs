[{"data":1,"prerenderedAt":80},["Reactive",2],{"search-api":3},[4,11,26,37,48,56,65,72],{"id":5,"path":6,"dir":7,"title":8,"description":7,"keywords":9,"body":10},"content:0.index.md","/","","Home",[],"     Rainlink: Compatible with Nodelink, Lavalink and more in one client.   Designed to modularize lavalink/nodelink server management classes. Rainlink provides a solution that is compatible with any future version of lavalink/nodelink within the same codebase. You don't need to change too much or even your source code to still be able to run lavalink v3.7 as well as v4.     Stable client  Support TypeScript  100% Compatible with Lavalink  Object-oriented  Easy to setup  Inbuilt Queue System  Extendable Player, Queue, Rest class  Backward compatible (Can run lavalink version 3.7.x)  Driver based (avaliable to run Nodelink v2 and port older lavalink version)  Plugin system",{"id":12,"path":13,"dir":14,"title":15,"description":16,"keywords":17,"body":25},"content:1.introduction:1.getting-started.md","/introduction/getting-started","introduction","Introductions","The world of JavaScript (JS) is filled with numerous lavalink clients and wrappers. There are currently around 140 of these clients available, but a major drawback is that each one only works with a specific lavalink version. While Riffy existed in the past, I found it to be limited in terms of scalability and compatibility with other versions. This is what inspired me to create a lavalink client that can seamlessly integrate with both older and upcoming lavalink versions. I'm excited to introduce this project to everyone - rainlink, also known as rainlink.js!",[18,19,20,21,22,23,24],"So what's rainlink?","What is Lavalink?","How to configure Lavalink?","What is Nodelink?","How to configure Nodelink?","How to download the Rainlink package?","Where I can find rainlink API doc?","  Introductions  The world of JavaScript (JS) is filled with numerous lavalink clients and wrappers. There are currently around 140 of these clients available, but a major drawback is that each one only works with a specific lavalink version. While Riffy existed in the past, I found it to be limited in terms of scalability and compatibility with other versions. This is what inspired me to create a lavalink client that can seamlessly integrate with both older and upcoming lavalink versions. I'm excited to introduce this project to everyone - rainlink, also known as rainlink.js!  So what's rainlink?  rainlink (a.k.a rainlink.js) is a lavalink client designed to modularize the lavalink/nodelink server management layers to make it easier for your discord music bot to be compatible with most versions of lavalink as well as nodelink. Currently rainlink is supporting lavalink versions from 3.7 to 4.x as well as nodelink v2. Additionally, in the future, I may port more older versions of lavalink and nodelink  What is Lavalink?  Lavalink is an audio playback server designed for Discord applications. It supports audio streaming from various sources, including popular platforms like YouTube and SoundCloud. Lavalink provides a robust infrastructure for efficient audio handling, ensuring a smooth and high-quality audio experience for end users.  How to configure Lavalink?  For detailed information on configuring Lavalink and other important considerations, please refer to the official documentation available at   Lavalink . There, you will find step-by-step guidance, practical examples, and information on the configuration requirements necessary to successfully integrate Lavalink into your development environment.  What is Nodelink?  Nodelink is also an audio playback server designed for Discord applications but made in JS. It is an alternative to Lavalink as Lavalink takes up a lot of resources while still maintaining Lavalink's API.  How to configure Nodelink?  For detailed information on configuring Nodelink and other important considerations, please refer to the official documentation available at   Nodelink . There, you will find step-by-step guidance, practical examples, and information on the configuration requirements necessary to successfully integrate Lavalink into your development environment. The connection method is similar to lavalink  How to download the Rainlink package?  To install Rainlink in your project, you can use a package manager like npm, yarn, or pnpm. Simply execute the appropriate command in your terminal:     npm   install   rainlink\n  or     yarn   add   rainlink\n  or     pnpm   install   rainlink\n  After successful installation, you'll be ready to start using all the powerful features offered by rainlink in your Discord project.   Currently, rainlink does not support Bun. After implementing RFC 6455 code using native packages to reduce its size, an important function, net.createConnection(), is not called by Bun. Make sure to consider this when planning your integration.  Where I can find rainlink API doc?  You can find rainlink API doc by using this link:   https://docs-rainlinkjs.vercel.app/  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":27,"path":28,"dir":14,"title":29,"description":30,"keywords":31,"body":36},"content:1.introduction:2.how-to-use.md","/introduction/how-to-use","How to use rainlink?","Here, I will show you how to use rainlink in the simplest way possible.",[32,33,34,35],"Understanding the Driver","Understanding the Structure","Player and Node Management","Understanding Lavalink","  How to use rainlink?  Here, I will show you how to use rainlink in the simplest way possible.  Understanding the Driver  Driver in Rainlink is a class contain all basic communication function with lavalink/nodelink like WS/REST hadling.  The main features of driver is making a way to translate all current WS/REST api response to lavalink v4 api response. This will make Rainlink can run able on lavalink v3 and portable.  Currently, driver developing is not documented and supported. If you want, you can try.  This is the list of all rainlink driver currently supported (codename is made up by me) \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n     Driver Name  Voice Server  Language  Supported Version  Codename  Notes    lavalink/v4/koinu  Lavalink  Java  v4.0.0 - v4.x.x  koinu    lavalink/v3/koto  Lavalink  Java  v3.0.0 - v3.7.x  koto   filter  and   resume  in lavalink below v3.4 not supported   nodelink/v2/nari  Nodelink  Javascript  v2.0.0 - v2.x.x  nari  Some   filter  mode in nodelink not supported  Understanding the Structure  At the core of Rainlink is the   Rainlink  class, which serves as the primary interface for interacting with its features. This class encapsulates essential functionalities, including driver, plugin, player and node management, ensuring a cohesive experience for developers. Example of how to init   Rainlink :     const   rainlink   =   new   Rainlink  ({\n     library:   new   Library.  DiscordJS  (client),\n     nodes: [{\n       name:   'owo'  ,\n       host:   'localhost'  ,\n       port:   2333  ,\n       auth:   'youshallnotpass'  ,\n       secure:   false  ,\n       // You don't have to add this properties if you're using lavalink v4.\n       // If you use a version other than lavalink, you can refer to the Understanding the Driver section above\n       driver:   \"lavalink/v4/koinu\"\n     }]\n   });\n  Player and Node Management  One of the key aspects of Rainlink is its modular approach to player and node management. By dividing responsibilities into distinct classes, such as   RainlinkPlayer  and   NodeManager , Rainlink enhances clarity and organization within your application.  Players  Players represent entities responsible for audio playback within a specific context, such as a Discord server. The   RainlinkPlayer  class handles player-related operations, offering functions for retrieving existing players, creating new ones, and accessing player-specific functionalities.  Retrieving Players  To retrieve a player associated with a particular Discord server, you can use the   get  method:     \u003C  Rainlink  >.players.  get  (  \"myGuildIdDiscord\"  )\n  Retrieving Players  To retrieve a player associated with a particular Discord server, you can use the   get  method:     \u003C  Rainlink  >.players.  get  (  \"myGuildIdDiscord\"  )\n  Creating Players  Creating a new player involves specifying relevant parameters, such as the Discord guild ID, guild shard ID associated voice/text channels:     \u003C  Rainlink  >.  create  ({\n     guildId:   \"id\"  ,\n     textId:   \"voiceId\"  ,\n     voiceId:   \"textId\"  ,\n     shardId:   \"\u003Cyour_guild_shard_id>\"   ||   0\n   })\n  Node Management  Nodes are essential components in Moonlink responsible for handling audio streams and distributing workload efficiently. The   RainlinkNode  class facilitates node management operations, offering functionalities for adding, retrieving, and removing nodes.  Adding Nodes  To add a new node, you can use the   add  method, specifying parameters such as host, password, and port:     \u003C  Rainlink  >.nodes.add({\n     name:   \"example lavalink\"  ,   // You can set whatever you want\n     host:   \"example.com\"  ,\n     port:   2333  ,\n     auth:   \"securePassword\"  ,\n     secure:   false  ,   // Set true if your lavalink have ssl\n     // You don't have to add this properties if you're using lavalink v4.\n     // About using lavalink v3.7.x, you can change to lavalink@3\n     // About using nodelink v2, you can change to nodelink@2\n     driver:   \"lavalink@4\"\n   })\n  Retrieving Nodes  You can retrieve a node using identifier:     \u003C  Rainlink  >.nodes.  get  (  \"example lavalink\"  )\n  Removing Nodes  You can remove a node using identifier:     \u003C  Rainlink  >.nodes.  remove  (  \"example lavalink\"  )\n  Understanding Lavalink  Lavalink serves as a simplified audio playback server, functioning as both an API and a WebSocket server for manipulating audio streams. It interfaces with LavaPlayer, which manages audio sources and related functionalities. Additionally, it includes Koe, similar to   @discordjs/voice , facilitating connections with Discord for audio transmission.  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":38,"path":39,"dir":40,"title":41,"description":42,"keywords":43,"body":47},"content:2.development:1.regular-plugin.md","/development/regular-plugin","development","Regular plugin","So you are interested in using Rainlink and want to create your own plugin to extend some of Rainlink's features, so this page can help you somewhat.",[44,45,46],"Understanding how plugin works","Requirements","Example plugin code (YoutubeConverter / Not Release):","  Regular plugin  So you are interested in using Rainlink and want to create your own plugin to extend some of Rainlink's features, so this page can help you somewhat.  Understanding how plugin works  Basically, the plugin in Rainlink will work by overriding the   Rainlink  class by adding or overriding variables and functions in it. Hence why it is called a plugin.  Requirements   Using   rainlink  package.  Extend   RainlinkPlugin  class.  Class named   RainlinkPlugin  (You can use   import { RainlinkPlugin as Plugin } from \"rainlink\";  to avoid error).  Have   name()  function return the name of that plugin.  Have   type()  function return the type of that plugin using   RainlinkPluginType  enum. In this article, we will use   default .  Have   load()  function to load all the modded function of that plugin.  Have   unload()  function to unload all the modded function of that plugin.    Do you know?    You can check all the requirement on   src/Plugin/RainlinkPlugin.ts  in   official repo .   default  type is different from   sourceResolver . I will talk about   sourceResolver  later.  Example plugin code (YoutubeConverter / Not Release):  index.ts     import   { RainlinkPlugin }   from   \"./plugin\"  ;\n   export   { RainlinkPlugin   as   DeezerPlugin }\n  plguin.ts     import   { RainlinkTrack }   from   \"rainlink\"  ;\n   import   { RainlinkPluginType }   from   \"rainlink\"  ;\n   import   { RainlinkSearchOptions, RainlinkSearchResult, RainlinkSearchResultType }   from   \"rainlink\"  ;\n   import   { Rainlink }   from   \"rainlink\"  ;\n   import   { RainlinkPlugin   as   Plugin }   from   \"rainlink\"  ;\n   \n   const   YOUTUBE_REGEX   =   [\n     /  ^  https  ?  :  \\/\\/  /  ,\n     /  (?:https  ?  :  \\/\\/  )  ?  (?:www  \\.  )  ?  youtu(?:  \\.  be  \\/  |  be  .  com  \\/  \\S  *  (?:watch  |  embed)(?:(?:(?=  \\/  [-a-zA-Z0-9_]  {11,}  (?!  \\S  ))  \\/  )  |  (?:  \\S  *  v=  |  v  \\/  )))(  [-a-zA-Z0-9_]  {11,}  )  /  ,\n     /  ^  .  *  (youtu  .  be  \\/  |  list=)(  [  ^  #  \\&\\?  ]  *  )  .  *  /  ,\n   ];\n   \n   export   type   YoutubeConvertOptions   =   {\n     sources  ?:   string  [];\n   };\n   \n   export   class   RainlinkPlugin   extends   Plugin   {\n     private   options  :   YoutubeConvertOptions  ;\n     private   _search  ?:   (  query  :   string  ,   options  ?:   RainlinkSearchOptions  )   =>   Promise  \u003C  RainlinkSearchResult  >;\n     constructor  (  options  ?:   YoutubeConvertOptions  ) {\n       super  ();\n       this  .options   =   options   ??   { sources: [  \"scsearch\"  ] };\n       if   (  !  this  .options.sources   ||   this  .options.sources.  length   ==   0  )   this  .options.sources   =   [  \"scsearch\"  ];\n     }\n     /** Name function for getting plugin name */\n     public   name  ()  :   string   {\n       return   \"rainlink-youtubeConvert\"  ;\n     }\n   \n     /** Type function for diferent type of plugin */\n     public   type  ()  :   RainlinkPluginType   {\n       return   RainlinkPluginType.Default;\n     }\n   \n     /** Load function for make the plugin working */\n     // eslint-disable-next-line @typescript-eslint/no-unused-vars\n     public   load  (  manager  :   Rainlink  )  :   void   {\n       this  ._search   =   manager.search.  bind  (manager);\n       manager.search   =   this  .search.  bind  (  this  );\n     }\n   \n     /** unload function for make the plugin stop working */\n     // eslint-disable-next-line @typescript-eslint/no-unused-vars\n     public   unload  (  manager  :   Rainlink  )  :   void   {\n       if   (  !  this  ._search)   return  ;\n       manager.search   =   this  ._search.  bind  (manager);\n       this  ._search   =   undefined  ;\n     }\n   \n     private   async   search  (  query  :   string  ,   options  ?:   RainlinkSearchOptions  )  :   Promise  \u003C  RainlinkSearchResult  > {\n       // Check if search func avaliable\n       if   (  !  this  ._search)   return   this  .  buildSearch  (  undefined  , [], RainlinkSearchResultType.  SEARCH  );\n   \n       // Check if that's a yt link\n       const   match   =   YOUTUBE_REGEX  .  some  ((  match  )   =>   {\n         return   match.  test  (query)   ==   true  ;\n       });\n       if   (  !  match)   return   await   this  .  _search  (query, options);\n   \n       // Get search query\n       const   preRes   =   await   this  .  _search  (query, options);\n       if   (preRes.tracks.  length   ==   0  )   return   preRes;\n   \n       // Remove track encoded to trick rainlink\n       if   (preRes.type   ==   RainlinkSearchResultType.  PLAYLIST  ) {\n         for   (  const   track   of   preRes.tracks) {\n           track.encoded   =   \"\"  ;\n         }\n         return   preRes;\n       }\n   \n       const   song   =   preRes.tracks[  0  ];\n       const   searchQuery   =   [song.author, song.title].  filter  ((  x  )   =>   !!  x).  join  (  \" - \"  );\n       const   res   =   await   this  .  searchEngine  (searchQuery, options);\n       if   (res.tracks.  length   !==   0  )   return   res;\n       return   preRes;\n     }\n   \n     private   async   searchEngine  (  query  :   string  ,   options  ?:   RainlinkSearchOptions  )  :   Promise  \u003C  RainlinkSearchResult  > {\n       if   (  !  this  ._search)   return   this  .  buildSearch  (  undefined  , [], RainlinkSearchResultType.  SEARCH  );\n       for   (  const   SearchParams   of   this  .options.sources  !  ) {\n         const   res   =   await   this  .  _search  (  `directSearch=${  SearchParams  }:${  query  }`  , options);\n         if   (res.tracks.  length   !==   0  )   return   res;\n       }\n       return   this  .  buildSearch  (  undefined  , [], RainlinkSearchResultType.  SEARCH  );\n     }\n   \n     private   buildSearch  (\n       playlistName  ?:   string  ,\n       tracks  :   RainlinkTrack  []   =   [],\n       type  ?:   RainlinkSearchResultType\n     )  :   RainlinkSearchResult   {\n       return   {\n         playlistName,\n         tracks,\n         type: type   ??   RainlinkSearchResultType.  SEARCH  ,\n       };\n     }\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":49,"path":50,"dir":40,"title":51,"description":52,"keywords":53,"body":55},"content:2.development:2.source-resolver-plugin.md","/development/source-resolver-plugin","Source Resolver Plugin","Want to use any suitable music platform but can't find the official plugin? You can make it yourself right here!",[44,45,54],"Example source plugin:","  Source Resolver Plugin  Want to use any suitable music platform but can't find the official plugin? You can make it yourself right here!  Understanding how plugin works  Basically, the way it works will be similar to a regular plugin, but it will have stricter conditions so that you can search on lavalink and still be able to fallback to the plugin.  Requirements   Using   rainlink  package.  Extend   SourceRainlinkPlugin  class.  Class named   RainlinkPlugin .  Have   name()  function return the name of that plugin.  Have   type()  function return the type of that plugin using   RainlinkPluginType  enum. In this article, we will use   sourceResolver  Have   load()  function to load all the modded function of that plugin.  Have   unload()  function to unload all the modded function of that plugin.  Have   sourceName()  function return the name of that source. (For search from Lavalink, if it now avaliable, you can fill anything you want)  Have   sourceIdentify()  function return the ID of that source. (For search from Lavalink, if it now avaliable, you can fill anything you want)    Do you know?   You can check all the requirement on   src/Plugin/SourceRainlinkPlugin.ts  in   official repo .  Example source plugin: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n     Name  Type  Link  Author    rainlink-nico  Official   npmjs  /   github  RainyXeon   rainlink-deezer  Official   npmjs  /   github  RainyXeon   rainlink-apple  Official   npmjs  /   github  RainyXeon   rainlink-spotify  Official   npmjs  /   github  RainyXeon",{"id":57,"path":58,"dir":40,"title":59,"description":60,"keywords":61,"body":64},"content:2.development:3.library.md","/development/library","Library","Are you a developer of the discord api library? Wow, I'm your fan too :0. Or you simply want the library you are using to support rainlink? Well, you can refer to this article.",[62,63],"Understanding how library implementation works","Example:","  Library  Are you a developer of the discord api library? Wow, I'm your fan too :0. Or you simply want the library you are using to support rainlink? Well, you can refer to this article.  Understanding how library implementation works  The way the Library class works is quite similar to   Shoukaku . So you can absolutely copy from   Shoukaku  to use in rainlink  Example:     import   { AbstractLibrary }   from   'rainlink'  ;\n   import   { RainlinkNodeOptions }   from   'rainlink'  ;\n   \n   export   class   OceanicJS   extends   AbstractLibrary   {\n       // sendPacket is where your library send packets to Discord Gateway\n       public   sendPacket  (  shardId  :   number  ,   payload  :   any  ,   important  :   boolean  )  :   void   {\n           return   this  .client.shards.  get  (shardId)?.  send  (payload.op, payload.d, important);\n       }\n   \n       // getId is a getter where the lib stores the client user (the one logged in as a bot) id\n       public   getId  ()  :   string   {\n           return   this  .client.user.id;\n       }\n   \n       // Listen attaches the event listener to the library you are using\n       public   listen  (  nodes  :   RainlinkNodeOptions  [])  :   void   {\n           // Only attach to ready event once, refer to your library for its ready event\n           this  .client.  once  (  'ready'  , ()   =>   this  .  ready  (nodes));\n           // Attach to the raw websocket event, this event must be 1:1 on spec with dapi (most libs implement this)\n           this  .client.  on  (  'packet'  , (  packet  :   any  )   =>   this  .  raw  (packet));\n       }\n   }\n  html .dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html.dark .shiki span {color: var(--shiki-dark);background: var(--shiki-dark-bg);font-style: var(--shiki-dark-font-style);font-weight: var(--shiki-dark-font-weight);text-decoration: var(--shiki-dark-text-decoration);}html .default .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}html .shiki span {color: var(--shiki-default);background: var(--shiki-default-bg);font-style: var(--shiki-default-font-style);font-weight: var(--shiki-default-font-weight);text-decoration: var(--shiki-default-text-decoration);}",{"id":66,"path":67,"dir":40,"title":68,"description":69,"keywords":70,"body":71},"content:2.development:4.driver.md","/development/driver","Driver","Currently, the driver API on Rainlink is quite complicated, so this section will temporarily be \"under development\". You can still develop your own, but there will be no documentation for you to refer to except in the Rainlink source code itself.",[],"  Driver  Currently, the driver API on Rainlink is quite complicated, so this section will temporarily be \"under development\". You can still develop your own, but there will be no documentation for you to refer to except in the Rainlink source code itself.",{"id":73,"path":74,"dir":75,"title":76,"description":77,"keywords":78,"body":79},"content:3.api:1.api-documentation.md","/api/api-documentation","api","API Documentation","Regarding API documentation, you can refer to the page: https://docs-rainlinkjs.vercel.app/",[],"  API Documentation  Regarding API documentation, you can refer to the page:   https://docs-rainlinkjs.vercel.app/",1713532994294]